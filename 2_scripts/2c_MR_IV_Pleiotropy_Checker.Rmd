---
title: "2c_MR_IV_Pleiotropy_Checker"
author: "Jonathan Chan"
date: "2025-05-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggrepel)
library(otargen)
library(qvalue)
library(LDlinkR)
library(writexl)
rm(list=ls())

theme_set(theme_classic())
```

## Importer

```{r}
#GWAS Catalog Format or Excel format for CVD HugeAmp SNPs
#Ultimate output = list of SNPs in rsID format

importer <- function(path){
  
  if(str_detect(path,'\\_associations.tsv')){ #GWAS Catalog Format
    input_assocs <- read_tsv(path) %>%
      select(SNPS, `STRONGEST SNP-RISK ALLELE`, `RISK ALLELE FREQUENCY`, `P-VALUE`,`OR or BETA`)
    colnames(input_assocs) <- c('rsID','EA','EAF','pval','OR_beta')
    
    input_assocs <- input_assocs %>%
      mutate(EA = str_match(EA, '-([A-Za-z]+)')[,2])
    
  } else if (str_detect(path, '_instrument_details\\.tsv')){
    input_assocs <- read_tsv(path) %>%
      select(SNP, effect_allele.exposure, eaf.exposure,beta.exposure,pval.exposure)
    colnames(input_assocs)<- c('rsID','EA','EAF','OR_beta','pval')
    
  }
  
  else if (str_detect(path, '\\.xlsx')){ #CVD HugeAmp format
    input_assocs <- readxl::read_excel(path)
    colnames(input_assocs) <- c('rsID')
  } 
  
  return(input_assocs)
}

```

## IV Assumption 1: Relevance via P-value Evaluation

Normally instrumental variables have to have sufficient association with the exposure (i.e IV assumption of relevance).
For this case, we assume that the IVs imported are either GWS or for limited sample size GWASs e.g HCMR (<10^-5).
This is because these SNPs are generally derived from either

1. Supplementary Information of Papers e.g Tadros25
2. GWAS Catalog 'Associations'
3. CVD HugeAmp Manual Curation

## IV Assumption 2: Exchangeability 

This assumes that there are no common causes of the instrumental variables and the outcome i.e confounders of IV and outcome.

This can be invalidated by processes such as 

1. Dynastic effects (i.e. parents affecting the phenotype of offspring via mechanism independent of genotype e.g 
parents have SNPs driving towards higher educational attainment -> home environment fostering academic success in children irrespective of the SNPs the children inherit)

This creates environmental confounders between the IV (offspring's inheritance of SNP) and the outcome (offspring's educational success).

2. Assortative mating (i.e where individuals choose mating partners more similar to themselves than expected by chance)

This can result in confounding between the IV (offspring's inheritance of SNP) and the outcome (e.g disease) due to social factors as a common cause i.e social factors can drive both certain couples to pair together and likewise affect outcome.

3. Population stratification (i.e population being divided into certain subgroups due to differences in allele frequencies and correlation of these subgroups with different phenotype due to different environments/cultures etc.)

This is generally adjusted for via inclusion of genetic PCs in the underlying GWAS itself.


## IV Assumption: Exclusion Restriction

### V2G

This assumes that the IVs only act on the outcome via the exposure pathway and no other pathways.

```{r}
otg_v2g_caller <- function(input_snp){
  
  #Call OTG
  safe_v2g <- safely(genesForVariant) #This extracts the prioritised genes for each variant
  
  otg_v2g_data <- safe_v2g(input_snp)
  
  #Extract out important information e.g p-value; beta
 if ( class(otg_v2g_data$result) == 'NULL') {#i.e has information returned
    print(str_c('No OTG V2G data for SNP ', input_snp))
    return(NULL)
  } else {
    processed_v2g_data <- as_tibble(otg_v2g_data$result$v2g)
    return(processed_v2g_data)
  }

}

v2g_saver_plotter <- function(v2g,og_tb, pheno, output_path='../3_output/1_MR_QC/v2g_check/' ){
  saveRDS(v2g, str_c(output_path, pheno, '_v2g.rds'))
  
  combined_data <- compact(v2g) #Removes NULL elements
  combined_data <- map_dfr(names(combined_data), ~{ #Combines into a single tibble
    v2g[[.x]] %>%
      mutate(snp_id = .x)
  }) 
  
  ## Add p-value of the SNP association
  combined_data <- left_join(combined_data,select(og_tb,rsID,pval), by=c('snp_id'='rsID'))
  
  if (nrow(combined_data) > 0) {
  
    # Step 4: Filter for Top 5 genes per SNP based on overallScore
    # We also need to ensure we keep the pval associated with the snp_id for ordering later.
    # Since pval is the same for all genes of a given SNP, we can take the first one.
    top_genes_data <- combined_data %>%
      group_by(snp_id) %>%
      slice_max(order_by = overallScore, n = 5, with_ties = FALSE) %>% # Get top 5, break ties by first encountered
      ungroup()
  
    print("Head of the data with Top 5 genes per SNP:")
    print(head(top_genes_data))
    print(paste("Number of rows in top_genes_data:", nrow(top_genes_data)))
  
    # Step 5: Prepare for facet ordering by p-value.
    # We need a summary table of snp_id and their pval to order the factor.
    snp_order_info <- top_genes_data %>%
      distinct(snp_id, pval) %>% # Get unique SNP-pval pairs
      arrange(pval) # Sort by pval to define the order
  
    # Reorder the snp_id factor levels based on pval
    # This ensures facets are plotted in ascending order of pval.
    top_genes_data$snp_id <- factor(top_genes_data$snp_id, levels = snp_order_info$snp_id)
  
    # For lollipop plot, it's good to order genes within each facet by score
    top_genes_data <- top_genes_data %>%
      arrange(snp_id, desc(overallScore)) %>% # Ensure genes are sorted for plotting
      mutate(gene.symbol = factor(gene.symbol, levels = unique(gene.symbol))) # Maintain this order
  
    print("Structure of data prepared for plotting:")
    str(top_genes_data)
    print("Factor levels for snp_id (should be ordered by pval):")
    print(levels(top_genes_data$snp_id))
  
  
    # --- Lollipop Plot Generation ---
  
    # Option 1A (Modified): Lollipop Plot, Faceted by SNP (ordered by pval), Top 5 genes
    plot_lollipop_top5_ordered <- ggplot(top_genes_data, aes(x = overallScore, y = reorder(gene.symbol, overallScore))) +
      geom_segment(aes(xend = 0, yend = gene.symbol, color = snp_id), linewidth = 0.8) + # Lollipop stick
      geom_point(aes(color = snp_id), size = 4) + # Lollipop dot
      facet_wrap(~ snp_id, ncol = 7, scales = "free_y") + # Adjust ncol as needed; free_y allows y-axes to adapt
      labs(
        title = "Top 5 Mapped Genes per SNP (Ordered by SNP P-value)",
        subtitle = "SNPs ordered by increasing p-value (lowest p-value first)",
        x = "Overall Score",
        y = "Gene Symbol (Top 5, Ordered by Score within SNP)"
      ) +
      theme_bw(base_size = 12) + # Increase base font size
      theme(
        axis.text.y = element_text(size = 9), # Adjust gene symbol text size
        axis.text.x = element_text(size = 9),
        strip.text = element_text(size = 10, face = "bold"), # SNP ID labels in facets
        legend.position = "none", # Color is redundant with facets if each SNP has a unique color mapping
        panel.spacing.x = unit(1.5, "lines"), # Add a bit more space between facets
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, size = 10)
      ) +
      scale_x_continuous(expand = expansion(mult = c(0.01, 0.05))) # Ensure origin is visible and some space
  
    print(plot_lollipop_top5_ordered)
  
  } else {
    print("Skipping plot generation as there is no data to plot.")
  }
  
  ggsave(str_c(output_path, pheno, '/', pheno, '_v2g_facetted_plot.png'),plot_lollipop_top5_ordered, dpi=600, width = 25, height = 15, create.dir=T)
  
}

main <- function(path, pheno){ #For V2G
  
  print(str_c('Importing in ', path))
  input_assocs <- importer(path)
  v2g <- map(input_assocs$rsID, ~otg_v2g_caller(.))
  names(v2g) <- input_assocs$rsID
  
  print(str_c('Plotting the V2G summary for each rsID'))
  v2g_saver_plotter(v2g, input_assocs, pheno)
}
```

### Pleiotropy Evaluation

This leverages Open Target Genetics PheWAS to evaluate SNP's pleiotropy and plots out the other traits which the SNP has statistical significant association with (defined by pval_cutoff).

```{r}
otg_caller_processor <- function(input_snp){

  # Call OTG
  safe_pheWAS <- safely(pheWAS)
  otg_phewas_data <- safe_pheWAS(input_snp)

  # Extract out important information e.g p-value; beta
  if (is.null(otg_phewas_data$result)) { # i.e. no information returned
    print(str_c('No OTG PheWAS data for SNP ', input_snp))
    return(NULL) # Return NULL or an empty tibble if no data
  } else {
    processed_phewas_data <- as_tibble(otg_phewas_data$result) %>%
      mutate(SNP = input_snp)

    # Define all expected columns and their corresponding names in the input data
    # The order here defines the output column order
    expected_columns <- c(
      "SNP" = NA, # This is added by mutate, so just a placeholder for structure
      "StudyID" = "study.studyId",
      "Trait" = "study.traitReported",
      "pvalue" = "pval",
      "Beta" = "beta",
      "PMID" = "study.pmid",
      "StudySource" = "study.source",
      "StudyDate" = "study.pubDate",
      "N.Overall" = "nTotal"
    )

    # Create an empty tibble with all expected columns
    # This ensures all columns are present, even if not in the original data
    final_tibble <- tibble(.rows = nrow(processed_phewas_data))
    for (col_name in names(expected_columns)) {
      if (col_name == "SNP") {
        final_tibble[[col_name]] <- processed_phewas_data$SNP
      } else if (expected_columns[col_name] %in% names(processed_phewas_data)) {
        final_tibble[[col_name]] <- processed_phewas_data[[expected_columns[col_name]]]
      } else {
        final_tibble[[col_name]] <- NA_real_ # Use NA_real_ for numeric, NA_character_ for character, etc.
                                           # Or simply NA if you don't care about type upfront
      }
    }

    # Ensure the correct column types if needed (optional, but good practice)
    # You might want to refine this based on the expected type of each column
    final_tibble <- final_tibble %>%
      mutate(
        SNP = as.character(SNP),
        StudyID = as.character(StudyID),
        Trait = as.character(Trait),
        pvalue = as.numeric(pvalue),
        Beta = as.numeric(Beta),
        PMID = as.character(PMID), # PMIDs can be numeric or character based on source
        StudySource = as.character(StudySource),
        StudyDate = as.character(StudyDate), # Or as.Date if format is consistent
        N.Overall = as.numeric(N.Overall)
      )

    return(final_tibble)
  }
}

#This applies multiple testing correction to filter for only MTC-significant pleiotropic associations.

fdr_corrector <- function(processed_data_tb, fdr_cutoff=0.05){
  #Generate a FDR for each study's association taking into account that OTG only reports studies with a pvalue < 0.005 so need to use qvalue_truncp() as in qvalue R package as in Harper et al, 2021 Supp. Table 25
  
  #This outputs the adjusted p-value for each study within a SNP. The input_tb is on a per-SNP basis.
  safe_qvalue_truncp <- safely(qvalue_truncp)
  
  qvals <- safe_qvalue_truncp(processed_data_tb$pvalue,fdr.level = fdr_cutoff,pfdr=T)
  qvals <- qvals$result
  
  if(is_null(qvals)){
    output <- processed_data_tb %>%
      mutate(qvalue = NA)
  } else{
      output <- bind_cols(processed_data_tb, qvalue=qvals$qvalues)
  }
  
  return(output)
}

scatter_plotter <- function(processed_data_tb, pheno, output_path, qval_cutoff=0.05, priority_cutoff=50){
  theme_set(theme_classic())
  
  snp <- unique(processed_data_tb$SNP)
  processed_data_tb2 <- processed_data_tb %>% filter(qvalue < qval_cutoff) #This filters the PheWAS results for only those where the SNP is associated at GWS with the trait.
  
  if(length(unique(processed_data_tb2$Trait))>=priority_cutoff){ #This defines a priority file prefix if there is > n significant signals PRIOR to MTC across phenotypes btw
    prefix <- 'priority_'
  } else {prefix <- ''}
  
  if(nrow(processed_data_tb2) > 0){
    
    out <- ggplot(processed_data_tb2, aes(y=Trait, x=-log10(qvalue)))+
      geom_point(aes(col=StudySource))+
      ylab('Trait')+
      xlab('-log10(FDR-adjusted p-value)')+
      labs(title=str_c('PheWAS from OTG for SNP ', snp))
    
    print(out)
    ggsave(str_c(output_path, '/2_phewas_plots/',pheno, '/',prefix,snp,'_phewas_scatter.png'),out,dpi=600, create.dir=T, width=15, height =12)
  }
  
}

allsnp_merger_writer <- function(fdr_corrected_data, pheno, output_path, fdr_cutoff=0.05){
  
  output <- fdr_corrected_data %>% bind_rows() %>%
    filter(qvalue < fdr_cutoff) #This requires the adjusted p-value to be at least 0.01
  
  write_tsv(output, str_c(output_path,pheno,'_phewas_FDRfiltered.tsv'))
  
  return(output)
}

pairwise_LD_checker <- function(input_SNPs,pheno, output_path, token, population='GBR'){ #Note this API token means don't push this to Git
  
  all_possible_combinations <- expand_grid(input_SNPs, input_SNPs)
  colnames(all_possible_combinations) <- c('var1','var2')
  all_possible_combinations <- filter(all_possible_combinations, var1 != var2)
  
  safe_LDpair <- safely(LDpair)
  pairwise_ld_results <- map2(all_possible_combinations$var1,all_possible_combinations$var2, ~safe_LDpair(.x,.y,pop=population,token, genome_build='grch38_high_coverage')[['result']]) %>% bind_rows() %>% 
    filter(!is.na(p_val) & p_val < 0.05)

  
  write_tsv(pairwise_ld_results, str_c(output_path,pheno,'_pairwiseLD.tsv'))
  
  return(pairwise_ld_results)
}

#This is the main pleiotropy function
main2 <- function(path, pheno, output_path, pairwise_LD_check = F){
  
  print(str_c('Importing in ', path))
  input_assocs <- importer(path)
  
  if (file.exists(str_c(output_path, '/1_OTG_RDS/',pheno, '_phewas_results.rds'))){
    processed_data <- read_rds(str_c(output_path, '/1_OTG_RDS/',pheno, '_phewas_results.rds'))
  } else {
    processed_data <- map(input_assocs$rsID, ~otg_caller_processor(.))
    processed_data <- processed_data[map_lgl(processed_data, ~!is.null(.))]
    write_rds(processed_data,str_c(output_path, '/1_OTG_RDS/',pheno, '_phewas_results.rds'))
  }

  fdr_corrected_data <- map(processed_data, ~fdr_corrector(.)) #This performs MTC for the pleiotropy analysis
  walk2(fdr_corrected_data, pheno, ~scatter_plotter(.x, .y, output_path))
    
  fdrsig_signals <- allsnp_merger_writer(fdr_corrected_data, pheno, output_path)
  
  #Output a summary table of the number of unique FDR-significant traits per SNP
  summary_table <- fdrsig_signals %>%
    group_by(SNP) %>%
    summarize(NumberOfUniqueTraits = length(unique(Trait))) %>%
    ungroup() %>%
    arrange(desc(NumberOfUniqueTraits))
  
  write_tsv(summary_table, str_c(output_path, pheno, '_phewas_FDRfiltered_summaryN.tsv'))
  
  if(isTRUE(pairwise_LD_check)){
    token <- readRDS('ldlinkR_API_token.rds')
    pairwise_LD_checker(input_assocs$rsID, pheno, output_path, token)
  }
}
```


#### Call Functions

```{r}
#V2G
# main('../../EDA_HCMR/popgen/5_MR/output/ukb_noHarper_inclHCM/NTproBNP_to_hcm_instrument_details.tsv', pheno='NTproBNP')
```

```{r}
instrument_files <- c('../1_data/gwas_associations/tadros25_hcm_nonMTAG_associations.xlsx',
                      '../1_data/gwas_associations/roselli25_af_associations.xlsx',
                      '../1_data/gwas_associations/keaton24_dbp_associations.tsv',
                      '../1_data/gwas_associations/sidorenko24_bmi_associations.tsv',
                      '../1_data/gwas_associations/sakaue21_t2d_associations.tsv',
                      '../1_data/gwas_associations/liu18_SmokingInitiation_associations.tsv',
                      '../1_data/gwas_associations/nauffal24_t1time_associations.xlsx',
                      '../1_data/gwas_associations/thanaj22_maxLAVi_associations.tsv',
                      '../1_data/gwas_associations/thanaj22_long_dsr_associations.tsv',
                      '../1_data/gwas_associations/thanaj22_radial_dsr_associations.tsv'
                      )
phenotypes <- c('HCM','AF','DBP','BMI','T2D','SmokingInitiation','T1time','maxLAVi','longDSR','radialDSR')

walk2(instrument_files, phenotypes,~main2(.x,.y,'../3_output/1_MR_QC/pleiotropy_check/'))

```

Run for HCMR and UKB phenotypes as well.

```{r}
hcmr_instrument_files <- list.files('../1_data/gwas_associations/', pattern='hcmr[^\\.]+\\.xlsx', full.names = T)
hcmr_phenotypes <- str_match(basename(hcmr_instrument_files), '([^\\.]+)_associations\\.xlsx')[,2]

ukb_instrument_files <- list.files('../1_data/gwas_associations/', pattern='ukb[^\\.]+\\.xlsx', full.names = T)
ukb_phenotypes <- str_match(basename(ukb_instrument_files), '([^\\.]+)_associations\\.xlsx')[,2]

walk2(hcmr_instrument_files, hcmr_phenotypes,~main2(.x,.y,'../3_output/1_MR_QC/pleiotropy_check/'))
walk2(ukb_instrument_files, ukb_phenotypes,~main2(.x,.y,'../3_output/1_MR_QC/pleiotropy_check/'))
```
Run for subgroup HCMs as well.

```{r}
subgroup_hcm_instrument_files <- c('../1_data/gwas_associations/tadros25_sarcposhcm_nonMTAG_associations.xlsx',
                                   '../1_data/gwas_associations/tadros25_sarcneghcm_nonMTAG_associations.xlsx')
subgroup_hcm_phenotypes <- c('sarcposHCM','sarcnegHCM')
walk2(subgroup_hcm_instrument_files,subgroup_hcm_phenotypes,~main2(.x,.y,'../3_output/1_MR_QC/pleiotropy_check/'))
```

### Pleiotropy Filter

This performs filtering of SNPs which are pleiotropic via 2 criteria

1) Excess pleiotropy with many other unique traits
2) Pleiotropy with certain red-flag traits which are causally associated with the outcome.

```{r}

snp_pleio_filter <- function(og_path, pheno, output_path,red_flags='',pheno2='', n_cutoff=50){
  
  input_tb <- read_tsv(str_c(output_path,pheno,'_phewas_FDRfiltered.tsv'))
  
  #These are the SNPs which have pleiotropy with a red flag trait which is known to be causally associated with the outcome
  if(!identical(red_flags,'')){
    redflag_snps <- input_tb %>%
      group_by(SNP) %>%
      filter(str_detect(Trait, str_c(red_flags, collapse='|'))) %>%
      select(SNP) %>%
      unique()
  } else{
      redflag_snps <- input_tb %>% 
        filter(is.infinite(1))#i.e empty tibble
  }
    
  #These are the SNPs which have excess pleiotropy with many other traits
  n_failed_snps <- input_tb %>%
    group_by(SNP) %>%
    select(SNP, Trait) %>%
    mutate(NumberOfUniqueTraits = length(unique(Trait))) %>%
    ungroup() %>%
    filter(NumberOfUniqueTraits > n_cutoff) %>% 
    select(SNP) %>%
    unique()
  
      #Output the SNPs which fail the pleiotropy checks
  output_snps <- unique(c(redflag_snps$SNP, n_failed_snps$SNP))
 
  og_snps <- importer(og_path)
  
  print(str_c('Of ', length(unique(og_snps$rsID)), ' instruments, ', 'total of ',length(output_snps), ' instruments excluded with ',nrow(n_failed_snps), ' instruments excluded due to excessive pleiotropy with >', n_cutoff, ' traits and ', nrow(redflag_snps), ' instruments excluded due to association with traits linked to the oucome e.g. ', str_c(red_flags, collapse='|')))
  
  #Write out the tsv of rsIDs of SNPs which pass pleiotropy checks as well
  pleio_pass <- og_snps%>%
    filter(!rsID %in% output_snps) %>%
    select(rsid=rsID) %>%
    unique()
  
  if(pheno!='HCM'){
    write_xlsx(pleio_pass,str_c('../1_data/gwas_associations/1_pleio_pruned/',pheno, '_gwas_associations.xlsx'))
  } else{
    write_xlsx(pleio_pass,str_c('../1_data/gwas_associations/1_pleio_pruned/',pheno, '_to_', pheno2,'_gwas_associations.xlsx'))
  }
  
  
  #Also write out TSV of failed SNPs
  write_tsv(tibble(SNP=output_snps) %>%unique(), str_c(output_path, pheno, '_pleiofailedsnps.tsv'))
}
```

```{r}
#DEFINE THE RED FLAG TRAITS 
#For the X -> HCM
hcm_outcome_redflags <- c(
  'Body mass index',
  'Pulse pressure','Systolic blood pressure', 'Diastolic blood pressure',
  'Hypertension','Hypertensive diseases'
)
#There are obviously exceptions, when the exposure is BMI or DBP
bmi_exception <- c('Pulse pressure','Systolic blood pressure', 'Diastolic blood pressure',
  'Hypertension','Hypertensive diseases')
dbp_exception <- c('Body mass index')

## OVERALL RED FLAGS
redflags <- c(list('',hcm_outcome_redflags,dbp_exception,bmi_exception), rep(list(hcm_outcome_redflags), length(phenotypes)-4)) #i.e no red flag traits for HCM instruments but redflag traits for the phenotypes -> HCM
hcmr_redflags <- rep(list(hcm_outcome_redflags), length(hcmr_phenotypes))
ukb_redflags <- rep(list(hcm_outcome_redflags), length(ukb_phenotypes))
subgroup_hcm_redflags <- rep('', length(subgroup_hcm_phenotypes))
```

#### Call Functions

```{r}
#Run for public GWAS summstats
pwalk(list(instrument_files, phenotypes, redflags),~snp_pleio_filter(..1,..2,'../3_output/1_MR_QC/pleiotropy_check/',..3))

#Run the exceptions for BMI -> HCM and DBP -> HCM
snp_pleio_filter('../1_data/gwas_associations/tadros25_hcm_nonMTAG_associations.xlsx','HCM','../3_output/1_MR_QC/pleiotropy_check/',bmi_exception ,'BMI')
snp_pleio_filter('../1_data/gwas_associations/tadros25_hcm_nonMTAG_associations.xlsx','HCM','../3_output/1_MR_QC/pleiotropy_check/',dbp_exception ,'DBP')

#Run for internal HCMR and UKB GWAS summstats
pwalk(list(hcmr_instrument_files, hcmr_phenotypes, hcmr_redflags),~snp_pleio_filter(..1,..2,'../3_output/1_MR_QC/pleiotropy_check/',..3))
pwalk(list(ukb_instrument_files, ukb_phenotypes, ukb_redflags),~snp_pleio_filter(..1,..2,'../3_output/1_MR_QC/pleiotropy_check/',..3))

#Run for the HCM subgroups
pwalk(list(subgroup_hcm_instrument_files, subgroup_hcm_phenotypes, subgroup_hcm_redflags),~snp_pleio_filter(..1,..2,'../3_output/1_MR_QC/pleiotropy_check/',..3))

```


#Misc.

## Config.yaml Generator

This generates a config.yaml given an input of fixed parameters and the filepath for the `1_pleio_pruned/...associations.xlsx`

```{r}
#' Create a YAML configuration file for Mendelian Randomization analysis.
#'
#' This function generates a YAML file with specified parameters for a two-sample
#' Mendelian Randomization analysis, typically involving HCM (Hypertrophic Cardiomyopathy)
#' and another non-HCM phenotype.
#'
#' @param non_hcm_phenotype A string representing the name of the non-HCM phenotype
#'   (e.g., "BMI"). This will be used as d1_exposure and d2_outcome.
#' @param non_hcm_exposure_gwas_path A string, the file path to the GWAS summary statistics
#'   for the non-HCM phenotype. This will be used for d1_exposure_path and d2_outcome_path.
#' @param non_hcm_instruments_path A string, the file path to the instruments file for
#'   the non-HCM phenotype when it acts as an exposure (for d1_instruments).
#' @param output_yaml_file_path A string, the desired file path where the YAML
#'   configuration file will be saved (e.g., "config.yaml").
#'
#' @return Invisibly returns TRUE if successful, otherwise stops with an error.
#' @examples
#' \dontrun{
#' create_mr_yaml_config(
#'   non_hcm_phenotype = "BMI",
#'   non_hcm_exposure_gwas_path = "sidorenko24_bmi_gwas_ssf/final/sidorenko24_bmi_gwas_ssf.h.tsv.gz",
#'   non_hcm_instruments_path = "../1_data/gwas_associations/1_pleio_pruned/BMI_gwas_associations.xlsx",
#'   output_yaml_file_path = "bmi_hcm_mr_config.yaml"
#' )
#'
#' create_mr_yaml_config(
#'   non_hcm_phenotype = "SBP",
#'   non_hcm_exposure_gwas_path = "path/to/sbp_gwas.tsv.gz",
#'   non_hcm_instruments_path = "../1_data/gwas_associations/1_pleio_pruned/SBP_gwas_associations.xlsx",
#'   output_yaml_file_path = "sbp_hcm_mr_config.yaml"
#' )
#' }
create_mr_yaml_config <- function(non_hcm_phenotype,
                                  non_hcm_exposure_gwas_path,
                                  non_hcm_instruments_path,
                                  output_yaml_file_path,
                                  hcm_instruments_path = '../1_data/gwas_associations/1_pleio_pruned/HCM_to__gwas_associations.xlsx') {

  # Required package for YAML writing
  if (!requireNamespace("yaml", quietly = TRUE)) {
    stop("Package 'yaml' is required but not installed. Please install it using install.packages('yaml').")
  }
  # No need to explicitly call library(yaml) if using ::, but good for clarity if used frequently
  # library(yaml) 

  # --- Define static values based on the provided YAML structure ---
  # These values are fixed according to your example
  static_output_path_val <- '../3_output/2_MR/'
  static_ld_eur_bed_file_val <- '../../hcmr_ukbb/popgen/5_MR/pipeline_files/1kg_v3_ld/EUR'
  static_plink_binary_path_val <- '/well/PROCARDIS/jchan/bin/plink'

  # Details for d1 (Direction 1: non-HCM phenotype -> HCM)
  static_d1_outcome_phenotype_val <- 'HCM'
  static_d1_outcome_path_val <- 'tadros24_hcm_gwas_ssf/final/tadros24_hcm_gwas_ssf.h.tsv.gz'
  static_d1_ld_clump_val <- 'FALSE' # R logical FALSE becomes 'false' in YAML output

  # Details for d2 (Direction 2: HCM -> non-HCM phenotype)
  static_d2_exposure_phenotype_val <- 'HCM'
  static_d2_exposure_path_val <- 'tadros24_hcm_gwas_ssf/final/tadros24_hcm_gwas_ssf.h.tsv.gz'
  
  # Construct the path for d2_instruments dynamically
  # This path is for instruments when HCM is the exposure and non-HCM phenotype is the outcome
  # Example: '../1_data/gwas_associations/1_pleio_pruned/HCM_to_BMI_gwas_associations.xlsx'
  d2_instruments_path_val <- hcm_instruments_path
  static_d2_ld_clump_val <- 'FALSE' # R logical FALSE becomes 'false' in YAML output

  # --- Construct the list that represents the YAML structure ---
  config_data_list <- list(
    output_path = static_output_path_val,
    ld_eur_bed_file = static_ld_eur_bed_file_val,
    plink_binary_path = static_plink_binary_path_val,

    # Direction 1: non-HCM phenotype (exposure) -> HCM (outcome)
    d1_exposure = non_hcm_phenotype,
    d1_outcome = static_d1_outcome_phenotype_val,
    d1_exposure_path = non_hcm_exposure_gwas_path, # User-provided path for non-HCM GWAS
    d1_outcome_path = static_d1_outcome_path_val,  # Fixed path for HCM GWAS
    d1_instruments = non_hcm_instruments_path,     # User-provided path for non-HCM instruments
    d1_ld_clump = static_d1_ld_clump_val,

    # Direction 2: HCM (exposure) -> non-HCM phenotype (outcome)
    d2_exposure = static_d2_exposure_phenotype_val,
    d2_outcome = non_hcm_phenotype,                 # Non-HCM phenotype is the outcome here
    d2_exposure_path = static_d2_exposure_path_val,  # Fixed path for HCM GWAS (as exposure)
    d2_outcome_path = non_hcm_exposure_gwas_path,    # User-provided path for non-HCM GWAS (as outcome)
    d2_instruments = d2_instruments_path_val,        # Dynamically constructed path
    d2_ld_clump = static_d2_ld_clump_val
  )

  # --- Write the list to a YAML file ---
  tryCatch({
    yaml::write_yaml(config_data_list, file = output_yaml_file_path)
    message(paste0("Successfully created YAML configuration file at: ", output_yaml_file_path))
    invisible(TRUE) # Return TRUE invisibly on success
  }, error = function(e) {
    # Provide a more informative error message
    stop(paste0("Failed to write YAML file to '", output_yaml_file_path, "'. Error: ", e$message))
  })
}

```

```{r}
hcmr_instrument_pleiopruned <- str_c(dirname(hcmr_instrument_files),'/1_pleio_pruned/',hcmr_phenotypes, '_gwas_associations.xlsx')
ukb_instrument_pleiopruned <- str_c(dirname(ukb_instrument_files),'/1_pleio_pruned/',ukb_phenotypes, '_gwas_associations.xlsx')

hcmr_gwas_summstats <- str_c(hcmr_phenotypes, '_gwas_ssf/final/',hcmr_phenotypes,'_gwas_ssf.h.tsv.gz')
ukb_gwas_summstats <- str_c(ukb_phenotypes, '_gwas_ssf/final/',ukb_phenotypes,'_gwas_ssf.h.tsv.gz')

hcmr_yaml_outputpath <- str_c('../1_data/input_configs/',hcmr_phenotypes, '_and_HCM.yaml')
ukb_yaml_outputpath <- str_c('../1_data/input_configs/',ukb_phenotypes, '_and_HCM.yaml')


pwalk(list(hcmr_phenotypes, hcmr_gwas_summstats, hcmr_instrument_pleiopruned, hcmr_yaml_outputpath),
      ~create_mr_yaml_config(..1,..2,..3,..4))

pwalk(list(ukb_phenotypes, ukb_gwas_summstats, ukb_instrument_pleiopruned, ukb_yaml_outputpath),
      ~create_mr_yaml_config(..1,..2,..3,..4))
```

